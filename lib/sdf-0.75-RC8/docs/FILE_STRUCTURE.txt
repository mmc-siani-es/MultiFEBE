/* File structure: (assuming the id-string is "SDF format"):

 * 1.  Bytes 0-10 - file identifier string, including null char terminator 
 * 2.  Bytes 11-18 - 64-bit integer, containing file position of next byte
 *     in the header.  Byte 11 is also strlen(sdfstr)+1 .
 * 3.  Bytes 19-26 - 64-bit integer, containing file position of next byte
       in the data portion of the file (which starts at byte 2019).
       Byte 19 is also strlen(sdfstr)+1+sizeof(pos) .  The value of this
       integer should also be the filesize.
 * 4.  Bytes 27-30 - 32-bit integer, containing the number of datasets 
       currently written in the file.  Byte 27 is also
       strlen(sdfstr)+1 +2*sizeof(pos) .
 * 5.  Bytes 31-38 - 64-bit integer, containing the size of the file header,
       'hdrsize', counting from byte 19.  Initially this is set to HINITSZ, 
       whose default value is 2000.  hdrsize is increased in blocks of 
       HINITSZ bytes as needed.  As of version 0.74, HINITSZ can be set as 
       a compiler flag to other values if desired.  For the IDL versions of 
       sdf, this value can be set with the hinitsz keyword in sdf_write.
 * 6.  Bytes 39-2018 - A series of linefeed terminated strings, containing
       descriptions of the data to be written.  These strings are generated by
       the data_to_string function.  Byte 39 is also
       strlen(sdfstr)+1 + 2*sizeof(pos) + sizeof(i4) *sizeof(pos) .
 * 7.  Bytes 2019-eof - the data, with each dataset written squentially,
       in order.  Byte 2019 is also equal to
       strlen(sdfstr)+1+sizeof(pos)+hdrsize .  If hdrsize is larger than
       2000, the data will start correspondingly later in the file
       
       The integers in the header and the data are all written in large-endian
       byte order, if the data isn't simply byte data. */
